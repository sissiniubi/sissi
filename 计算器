#include <iostream> 
#include <stack>
#include <map>
#include <string> 
#include <typeinfo>
#include <math.h>

using namespace std ;

int is_niubi (char n) // 检测运算符号优先级 
{
	if (n == '*' || n == '/' )
	{
		return 2 ;
	}
	else if (n == '+' || n == '-')
	{
		return 1 ;
	}
	else if (n == '(')
	{
		return 0 ;
	}
}

int is_symbol(char Equation){
	if (!isalnum(Equation) && ( 
	Equation == '+' || 
	Equation == '-' || 
	Equation == '*' || 
	Equation == '/' ||
	Equation == '#'
	))
	{return 1;}
	return 0;
}
int main ( ) // str 为输入的中序表达式 
{
	char Equation;
	int ii=0;
	double temp1=0;
	int a=10;double b=1;double c=0;int cifang = 1 ;
	string str ;
	int tem=0 ;
	cout << "请输入需计算算式，每个数字之间以:隔开，形如:#12.4:，可进行+-*/单目负计算"  ;
	cin >> str ; 
	//规定一个栈oprt为字符栈， 一个字符数组记录后续输出
	stack <char> op ; 
	string end_out ;
	int j=0 , i=0 ;
	//从左到右扫描中缀表达式
	for (i ; i<str.length() ; i++)
	{
		//如果当前字符串不是运算符号有两条路（）或数字
		if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'||str[i] == '('|| str[i] == ')')
		{
			if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') 
			{
			//判断当前符号与栈顶符号优先级
				if( op.empty()) 
				{
					op.push(str[i]) ; 
				}
				else
				{
					if (is_niubi(op.top()) < is_niubi(str[i]) && op.top() != '(')
					{
						op.push(str[i]) ;
					}
					else if (is_niubi(op.top()) >= is_niubi(str[i])) // 退出栈顶元素，当前元素入栈 
					{
						end_out[j] = op.top() ;
						op.pop() ;
						j++ ;
						op.push(str[i]) ;
					}
					else if (op.top() == '(')
					{
						op.push(str[i]) ;
					}	  
				}
		} 
		else if(str[i] == '(' )
		{
			op.push(str[i]) ;
		} 
		else if(str[i] == ')')
		{
			while(1)
			{
				if(op.top() != '(' )
				{
					end_out[j] = op.top() ;
					op.pop() ;
					j ++ ;
				}
				else if (op.top() == '(')
				{
					op.pop() ;
					break ;
				}
					
			}
		}
		}
		else 
		{
			end_out[j] = str[i] ;
			j ++ ;
		}
	}
	while (!op.empty() )
	{
		end_out[j] = op.top() ;
		op.pop() ;
		j++ ;
	}
	cout << "后序输出为：" ; 
	for (int k=0 ; k<j ; k++)
	{
		cout << end_out[k];
	}
	 
//后续计算	
	stack <double> opnum ;
	int maohao=0 ; int xiaoshu=0 ; int fushu=0 ; int fuhao=0 ; int dig=0 ;
	for (int k=0 ; k < j ; k++)
	{
		if (maohao == 2)
		{
			if (fushu == 1)
			{
				opnum.push(0-c) ;
			}
			else if (fuhao == 0)
			{
				opnum.push(c) ;
			}
			else 
			{
				cout << endl << "单目负（#）输入有误，请退出程序重新输入" << endl ;
				return 0 ;
			} 
			maohao = 0 ;
			xiaoshu = 0 ;
			c = 0 ;
			a = 10 ;
			b = 1 ;
			fushu = 0 ;
			fuhao = 0 ;
			cifang = 1 ;
			dig  = 0 ;
		}
		if(maohao > 2)
		{
			cout << endl <<  "：输入错误，请退出程序重新输入" << endl ;
			return 0 ;			 
		}
		if (xiaoshu > 1)
		{
			cout << endl << "小数点输入错误，请退出程序重新输入" << endl ;
			return 0 ;
		}
		if(end_out[k] == ':' )
		{
			maohao = maohao + 1 ;
		}
		else if(isdigit(end_out[k]))
		{
			dig ++ ; 
			if(maohao == 1 && xiaoshu == 0)
			{
				c = c*a + (end_out[k] - '0') * b ;
			}
			else if (maohao == 1 && xiaoshu == 1)
			{
				for (int lll=1 ; lll<cifang ; lll++)
				{
					b*=b ;
				}
				c = c + (end_out[k] - '0') * (b) ;
				cifang ++ ;  
			}
			else //检验输入是否正确 
			{
				cout << endl << "被计算数字输入有误，请退出程序重新输入" << endl ;
				return 0 ;
			}
		}
		else if (end_out[k] == '.')
		{
			if (maohao == 1 && xiaoshu==0 && dig != 0)
			{
				a = 1 ;
				b = 0.1;
				xiaoshu = 1 ;
			}
			else
			{
				cout << endl << "小数点输入有误，请退出程序重新输入" << endl ;
				return 0 ;
			}
		}
		//如果是数字，就通过字符改变为数字，然后放入数字栈。（#数字直接变成0-的结果计入数字栈） 
		else if (is_symbol(end_out[k]) )// 如果是加减乘除，就从数字栈中出两个数字进行对应运算，算完后再压回栈
		{
			if (end_out[k] == '+')
			{ 
				double n = opnum.top() ;
				opnum.pop() ;
				double o = opnum.top() ;
				opnum.pop() ;
				double count = o+n ;
				opnum.push(count) ;  
			}
			else if (end_out[k] == '-')
			{
				double n = opnum.top() ;
				opnum.pop() ;
				double o = opnum.top() ;
				opnum.pop() ;
				double count = o-n ;
				opnum.push(count) ;
			}
			else if (end_out[k] == '*')
			{
				double n = opnum.top() ;
				opnum.pop() ;
				double o = opnum.top() ;
				opnum.pop() ;
				double count = o * n ;
				opnum.push(count) ;
			}
			else if (end_out[k] == '/' )
			{
				double n = opnum.top() ;
				opnum.pop() ;
				double o = opnum.top() ;
				opnum.pop() ;
				double count = o / n ;
				opnum.push(count) ;
			}
			else if (end_out[k] == '#')
			{
				if(maohao == 1 && fushu == 0)
				{
					fushu = 1 ;
				}
				else 
				{
					cout << endl << "单目负（#）输入有误，请退出程序重新输入" << endl ;
					return 0 ;
				} 
			}
			else
			{
				cout << endl << "计算符号输入有误，请退出程序重新输入" << endl ;
				return 0 ;
			}
		}
		else 
		{
			cout << endl << "第" << k << "位输入有误，请退出程序重新输入" << endl ;
			return 0 ; 
		}
	}
	//直到输入的string数组全部读完，如果数字栈中只有一个元素，则返回数字栈中的元素 ，否则返回输入有误 
	cout <<  endl << "答案是:" << opnum.top()  ;
	return 0 ; 	
}
